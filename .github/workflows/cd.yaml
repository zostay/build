name: Continuous Deployment

on:
  workflow_call:
    inputs:
      genifest-version:
        description: 'Version of genifest to install (e.g., "latest" or "1.0.0-rc6")'
        required: false
        type: string
        default: 'latest'
      genifest-group:
        description: 'Genifest group to run (e.g., "all", "config-only", "prod")'
        required: false
        type: string
        default: 'all'
      genifest-tag:
        description: 'Additional tag expression to apply (e.g., "!secret-*")'
        required: false
        type: string
        default: ''
      working-directory:
        description: 'Working directory containing genifest.yaml configuration'
        required: false
        type: string
        default: '.'
      output-mode:
        description: 'Output mode for genifest (auto, color, plain, markdown)'
        required: false
        type: string
        default: 'markdown'
      commit-changes:
        description: 'Whether to commit the manifest changes'
        required: false
        type: boolean
        default: true
      commit-message:
        description: 'Commit message for manifest changes'
        required: false
        type: string
        default: 'chore: update kubernetes manifests via genifest'
      push-changes:
        description: 'Whether to push committed changes (requires commit-changes: true)'
        required: false
        type: boolean
        default: true
      create-pr:
        description: 'Whether to create a pull request for the changes'
        required: false
        type: boolean
        default: false
      pr-target-branch:
        description: 'Target branch for the pull request (defaults to deploy-{source-branch})'
        required: false
        type: string
        default: ''
      git-user-name:
        description: 'Git user name for commits'
        required: false
        type: string
        default: 'github-actions[bot]'
      git-user-email:
        description: 'Git user email for commits'
        required: false
        type: string
        default: 'github-actions[bot]@users.noreply.github.com'
      environment-variables:
        description: 'Environment variables to set for genifest execution (JSON format, e.g. {"VAR1":"value1","VAR2":"value2"})'
        required: false
        type: string
        default: '{}'
      update-build-number:
        description: 'Whether to update the build number in object store'
        required: false
        type: boolean
        default: false
      build-number-app-name:
        description: 'Application name for build number (required if update-build-number is true)'
        required: false
        type: string
        default: ''
      build-number-image-name:
        description: 'Image name for build number'
        required: false
        type: string
        default: 'main'
      build-number-env-name:
        description: 'Environment name for build number'
        required: false
        type: string
        default: 'prod'
    outputs:
      changes-made:
        description: 'Whether any manifest changes were made'
        value: ${{ jobs.deploy.outputs.changes-made }}
      commit-sha:
        description: 'SHA of the commit with manifest changes (if committed)'
        value: ${{ jobs.deploy.outputs.commit-sha }}
      pr-number:
        description: 'Pull request number (if created)'
        value: ${{ jobs.deploy.outputs.pr-number }}
      pr-url:
        description: 'Pull request URL (if created)'
        value: ${{ jobs.deploy.outputs.pr-url }}

jobs:
  deploy:
    name: Update Manifests
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      changes-made: ${{ steps.check-changes.outputs.changes-made }}
      commit-sha: ${{ steps.commit.outputs.commit-sha }}
      pr-number: ${{ steps.create-pr.outputs.pr-number }}
      pr-url: ${{ steps.create-pr.outputs.pr-url }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      - name: Setup Git User
        env:
          GIT_USER_NAME: ${{ inputs.git-user-name }}
          GIT_USER_EMAIL: ${{ inputs.git-user-email }}
        run: |
          git config user.name "$GIT_USER_NAME"
          git config user.email "$GIT_USER_EMAIL"

      - name: Create Deployment Branch
        id: branch-setup
        if: inputs.create-pr
        env:
          TARGET_BRANCH: ${{ inputs.pr-target-branch }}
        run: |
          set -euo pipefail

          # Set up branch names
          if [ -z "$TARGET_BRANCH" ]; then
            DEPLOY_TARGET="deploy-${{ github.ref_name }}"
          else
            DEPLOY_TARGET="$TARGET_BRANCH"
          fi

          BUILD_TAG="${{ github.ref_name }}-${{ github.run_number }}.${{ github.run_attempt }}"
          BRANCH_NAME="deploy-$BUILD_TAG-$(date +%Y%m%d-%H%M%S)"

          echo "DEPLOY_TARGET=$DEPLOY_TARGET" >> $GITHUB_ENV
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "BUILD_TAG=$BUILD_TAG" >> $GITHUB_ENV

          echo "deploy-target=$DEPLOY_TARGET" >> $GITHUB_OUTPUT
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "build-tag=$BUILD_TAG" >> $GITHUB_OUTPUT

          # Check if the deploy-* branch exists
          if git ls-remote --exit-code --heads origin "$DEPLOY_TARGET" > /dev/null 2>&1; then
            echo "Deploy branch $DEPLOY_TARGET exists, updating it with latest changes from ${{ github.ref_name }}"
            # Fetch the existing deploy branch
            git fetch origin "$DEPLOY_TARGET:$DEPLOY_TARGET"
            # Create new deployment branch from current HEAD (which has latest changes)
            git checkout -b "$BRANCH_NAME"
            # Merge any deployment-specific changes from the existing deploy branch
            # This allows for deployment-only files that aren't in the source branch
            git merge "$DEPLOY_TARGET" --no-edit || {
              echo "Merge conflict detected. Deploy branch may need manual resolution."
              git merge --abort
              echo "Proceeding with deployment branch from current HEAD only"
            }
          else
            echo "Deploy branch $DEPLOY_TARGET does not exist, branching from current HEAD"
            git checkout -b "$BRANCH_NAME"
          fi

      - name: Install genifest
        env:
          GH_TOKEN: ${{ github.token }}
          INPUT_VERSION: ${{ inputs.genifest-version }}
        run: |
          set -euo pipefail
          echo "Installing genifest..."

          # Determine version to install
          if [ "$INPUT_VERSION" = "latest" ]; then
            VERSION=$(gh api repos/zostay/genifest/releases/latest --jq '.tag_name' | sed 's/^v//')
            if [ -z "$VERSION" ]; then
              echo "Error: Failed to fetch latest version"
              exit 1
            fi
            # Validate the fetched version follows semantic versioning
            if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$'; then
              echo "Error: Fetched version does not match expected format: $VERSION"
              exit 1
            fi
          else
            # Validate version format (semantic versioning with optional prerelease)
            if ! echo "$INPUT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$'; then
              echo "Error: Invalid version format: $INPUT_VERSION"
              echo "Expected format: X.Y.Z or X.Y.Z-prerelease (e.g., 1.0.0 or 1.0.0-rc6)"
              exit 1
            fi
            VERSION="$INPUT_VERSION"
          fi

          echo "Installing genifest version: $VERSION"

          # Detect platform
          OS_NAME=$(uname -s | tr '[:upper:]' '[:lower:]')
          OS_ARCH=$(uname -m)

          # Map architecture names
          if [ "$OS_ARCH" = "x86_64" ]; then
            OS_ARCH="amd64"
          elif [ "$OS_ARCH" = "aarch64" ]; then
            OS_ARCH="arm64"
          fi

          echo "Platform: $OS_NAME-$OS_ARCH"

          # Create local bin directory and add to PATH
          mkdir -p "$HOME/.local/bin"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

          # Download binary using GitHub CLI with built-in verification
          ASSET_NAME="genifest-$VERSION-$OS_NAME-$OS_ARCH"
          echo "Downloading asset: $ASSET_NAME"

          gh release download "v$VERSION" \
            --repo zostay/genifest \
            --pattern "$ASSET_NAME" \
            --output "$HOME/.local/bin/genifest"

          chmod +x "$HOME/.local/bin/genifest"

          # Verify installation
          "$HOME/.local/bin/genifest" version

      - name: Set Custom Environment Variables
        id: set-env-vars
        env:
          ENV_VARS_JSON: ${{ inputs.environment-variables }}
        run: |
          set -euo pipefail
          echo "Setting custom environment variables..."

          # Validate JSON format
          if ! echo "$ENV_VARS_JSON" | jq empty 2>/dev/null; then
            echo "Error: environment-variables input is not valid JSON format"
            echo "Expected format: {\"VAR1\":\"value1\",\"VAR2\":\"value2\"}"
            echo "Received: $ENV_VARS_JSON"
            exit 1
          fi

          # Check if we have any variables to set
          if [ "$ENV_VARS_JSON" = "{}" ]; then
            echo "No custom environment variables provided"
            echo "custom-vars-count=0" >> $GITHUB_OUTPUT
          else
            # Parse JSON and set environment variables
            echo "Parsing and setting environment variables..."
            VARS_COUNT=0

            # Create a temporary file to store environment exports
            ENV_FILE=$(mktemp)

            # Extract key-value pairs and export them
            echo "$ENV_VARS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
              # Validate variable name (must be valid shell variable name)
              if ! echo "$key" | grep -qE '^[A-Za-z_][A-Za-z0-9_]*$'; then
                echo "Error: Invalid environment variable name: $key"
                echo "Variable names must start with a letter or underscore and contain only letters, numbers, and underscores"
                exit 1
              fi

              # Export the variable for subsequent steps
              echo "$key=$value" >> $GITHUB_ENV
              echo "export $key=\"$value\"" >> "$ENV_FILE"
              echo "Set: $key"
              VARS_COUNT=$((VARS_COUNT + 1))
            done

            # Store the count for reporting
            VARS_COUNT=$(echo "$ENV_VARS_JSON" | jq '. | length')
            echo "custom-vars-count=$VARS_COUNT" >> $GITHUB_OUTPUT
            echo "Successfully set $VARS_COUNT custom environment variables"

            rm -f "$ENV_FILE"
          fi

      - name: Update Build Number
        if: inputs.update-build-number
        env:
          APP_NAME: ${{ inputs.build-number-app-name }}
          IMAGE_NAME: ${{ inputs.build-number-image-name }}
          ENV_NAME: ${{ inputs.build-number-env-name }}
          BUILD_NUMBER: ${{ github.run_number }}.${{ github.run_attempt }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
          AWS_ENDPOINT_URL: ${{ vars.AWS_ENDPOINT_URL }}
          BUILD_NUMBER_BUCKET: ${{ vars.BUILD_NUMBER_BUCKET }}
        run: |
          set -euo pipefail

          if [ -z "$APP_NAME" ]; then
            echo "Error: build-number-app-name is required when update-build-number is true"
            exit 1
          fi

          echo "Setting build number for ${APP_NAME}/${IMAGE_NAME}/${ENV_NAME} to ${BUILD_NUMBER}"

          # Download the set-build-number script if it doesn't exist
          if [ ! -f scripts/set-build-number ]; then
            echo "Downloading set-build-number script from zostay/build repository..."
            mkdir -p scripts
            curl -fsSL https://raw.githubusercontent.com/zostay/build/master/scripts/set-build-number -o scripts/set-build-number
            chmod +x scripts/set-build-number
          fi

          ./scripts/set-build-number "$APP_NAME" "$BUILD_NUMBER" --image-name "$IMAGE_NAME" --env-name "$ENV_NAME"

      - name: Validate Configuration
        working-directory: ${{ inputs.working-directory }}
        env:
          OUTPUT_MODE: ${{ inputs.output-mode }}
        run: |
          set -euo pipefail
          echo "Validating genifest configuration..."
          genifest validate --output="$OUTPUT_MODE"

      - name: Run genifest with Markdown Logging
        working-directory: ${{ inputs.working-directory }}
        env:
          GENIFEST_GROUP: ${{ inputs.genifest-group }}
          GENIFEST_TAG: ${{ inputs.genifest-tag }}
          OUTPUT_MODE: ${{ inputs.output-mode }}
          BUILD_TAG: ${{ env.BUILD_TAG }}
        run: |
          set -euo pipefail

          # Create genifest log with detailed information
          {
            echo "# Genifest Deployment Report"
            echo
            echo "**Branch:** ${{ github.ref_name }}"
            echo "**Build Tag:** ${BUILD_TAG:-${{ github.ref_name }}-${{ github.run_number }}.${{ github.run_attempt }}}"
            echo "**Genifest Group:** $GENIFEST_GROUP"
            echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo
            echo "## Environment Variables"
            echo
            if [ "${{ steps.set-env-vars.outputs.custom-vars-count }}" -gt 0 ]; then
              echo "**Custom variables set:** ${{ steps.set-env-vars.outputs.custom-vars-count }}"
              echo
              echo "**Custom Environment Variables:**"
              echo '```bash'
              echo "${{ inputs.environment-variables }}" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | sort
              echo '```'
              echo
            fi
            echo "<details><summary>All Environment Variables</summary>"
            echo
            echo '```bash'
            env | sort
            echo '```'
            echo
            echo "</details>"
            echo
            echo "## Genifest Version"
            echo
            echo '```'
            genifest version
            echo '```'
            echo
            echo "## Genifest Configuration"
            echo
            echo '```yaml'
            genifest config
            echo '```'
            echo
            echo "## Genifest Output"
            echo

            # Build command arguments safely using arrays
            ARGS=("run" "--output=$OUTPUT_MODE")

            # Add tag if specified (placed before group as per genifest CLI)
            if [ -n "$GENIFEST_TAG" ]; then
              ARGS+=("--tag" "$GENIFEST_TAG")
            fi

            # Add group argument
            ARGS+=("$GENIFEST_GROUP")

            echo "Running: genifest ${ARGS[*]}"
            echo
            genifest "${ARGS[@]}"
          } > genifest.log 2>&1 || {
            echo "Genifest failed with exit code $?"
            echo "Genifest log output:"
            cat genifest.log
            exit 1
          }

          # Display the log for workflow visibility
          cat genifest.log

      - name: Check for Changes
        id: check-changes
        run: |
          if git diff --quiet; then
            echo "No manifest changes detected"
            echo "changes-made=false" >> $GITHUB_OUTPUT
          else
            echo "Manifest changes detected:"
            git diff --stat
            echo "changes-made=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit Changes
        id: commit
        if: inputs.commit-changes && steps.check-changes.outputs.changes-made == 'true'
        env:
          COMMIT_MESSAGE: ${{ inputs.commit-message }}
          BUILD_TAG: ${{ env.BUILD_TAG }}
        run: |
          git add -A

          # Use BUILD_TAG in commit message if available, otherwise use the default message
          if [ -n "${BUILD_TAG:-}" ]; then
            FINAL_MESSAGE="Deploy ${BUILD_TAG} - ${COMMIT_MESSAGE}"
          else
            FINAL_MESSAGE="$COMMIT_MESSAGE"
          fi

          git commit -m "$FINAL_MESSAGE"

          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Committed changes with SHA: $COMMIT_SHA"

      - name: Push Changes
        if: inputs.commit-changes && inputs.push-changes && steps.check-changes.outputs.changes-made == 'true'
        env:
          BRANCH_NAME: ${{ env.BRANCH_NAME }}
        run: |
          if [ -n "${BRANCH_NAME:-}" ]; then
            # Push to the deployment branch if we created one
            git push origin "$BRANCH_NAME"
          else
            # Push to current branch for non-PR workflows
            git push
          fi

      - name: Create Pull Request
        id: create-pr
        if: inputs.create-pr && steps.check-changes.outputs.changes-made == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          DEPLOY_TARGET: ${{ env.DEPLOY_TARGET }}
          BRANCH_NAME: ${{ env.BRANCH_NAME }}
          BUILD_TAG: ${{ env.BUILD_TAG }}
        run: |
          set -euo pipefail

          PR_TITLE="Deploy ${BUILD_TAG} $(date +%Y%m%d-%H%M%S)"

          # Create PR with genifest log as the body
          PR_URL=$(gh pr create \
            --base "$DEPLOY_TARGET" \
            --head "$BRANCH_NAME" \
            --title "$PR_TITLE" \
            --body-file genifest.log)

          # Extract PR number from URL
          PR_NUMBER=$(echo "$PR_URL" | sed 's/.*\/pull\/\([0-9]*\)/\1/')

          echo "pr-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr-url=$PR_URL" >> $GITHUB_OUTPUT

          echo "Created pull request: $PR_URL"
