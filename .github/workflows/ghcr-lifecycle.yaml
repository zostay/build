name: GHCR Lifecycle Management

# Manages container image lifecycle in GitHub Container Registry (ghcr.io).
# Similar to AWS ECR lifecycle policies - prunes old images while keeping
# a minimum number of recent versions.
#
# Example (scheduled cleanup):
#   on:
#     schedule:
#       - cron: '0 0 * * 0'  # Weekly on Sunday at midnight
#     workflow_dispatch:      # Allow manual runs
#
#   jobs:
#     cleanup:
#       uses: zostay/build/.github/workflows/ghcr-lifecycle.yaml@master
#       with:
#         package-name: 'myapp'
#         min-versions-to-keep: 10
#         delete-after-days: 30
#       secrets:
#         GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
#
# Example (per-environment lifecycle with tag prefixes):
#   jobs:
#     cleanup:
#       uses: zostay/build/.github/workflows/ghcr-lifecycle.yaml@master
#       with:
#         package-name: 'myapp'
#         tag-prefixes: 'prod-,stg-'
#         min-versions-to-keep: 10
#         delete-after-days: 7
#       secrets:
#         GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
#
# Note: The GHCR_TOKEN must be a PAT with read:packages and delete:packages
# scopes, or use GITHUB_TOKEN if the workflow has packages: write permission.

on:
  workflow_call:
    inputs:
      package-name:
        description: 'Name of the container package to manage (e.g., "myapp" or "repo/myapp")'
        required: true
        type: string
      package-owner:
        description: 'Owner of the package (user or org). Defaults to repository owner.'
        required: false
        type: string
        default: ''
      min-versions-to-keep:
        description: 'Minimum number of versions to keep regardless of age (per tag prefix group if tag-prefixes is set)'
        required: false
        type: number
        default: 10
      delete-after-days:
        description: 'Versions older than this many days are eligible for deletion (after min-versions-to-keep is satisfied)'
        required: false
        type: number
        default: 30
      tag-prefixes:
        description: 'Comma-separated list of tag prefixes to manage independently (e.g., "prod-,stg-"). Each prefix group gets its own min-versions-to-keep quota.'
        required: false
        type: string
        default: ''
      dry-run:
        description: 'If true, only report what would be deleted without actually deleting'
        required: false
        type: boolean
        default: false
      include-untagged:
        description: 'If true, include untagged versions in cleanup (recommended)'
        required: false
        type: boolean
        default: true
      protected-tags:
        description: 'Comma-separated list of tag patterns to never delete (e.g., "latest,v*,prod-*")'
        required: false
        type: string
        default: 'latest'
    secrets:
      GHCR_TOKEN:
        description: 'GitHub token with packages read/delete permissions (PAT or GITHUB_TOKEN)'
        required: true
    outputs:
      deleted-count:
        description: 'Number of versions deleted'
        value: ${{ jobs.cleanup.outputs.deleted-count }}
      kept-count:
        description: 'Number of versions kept'
        value: ${{ jobs.cleanup.outputs.kept-count }}
      dry-run-would-delete:
        description: 'Number of versions that would be deleted (dry-run only)'
        value: ${{ jobs.cleanup.outputs.dry-run-would-delete }}

jobs:
  cleanup:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    outputs:
      deleted-count: ${{ steps.cleanup.outputs.deleted-count }}
      kept-count: ${{ steps.cleanup.outputs.kept-count }}
      dry-run-would-delete: ${{ steps.cleanup.outputs.dry-run-would-delete }}
    steps:
      - name: Cleanup Container Versions
        id: cleanup
        env:
          GH_TOKEN: ${{ secrets.GHCR_TOKEN }}
          PACKAGE_NAME: ${{ inputs.package-name }}
          PACKAGE_OWNER: ${{ inputs.package-owner || github.repository_owner }}
          MIN_VERSIONS: ${{ inputs.min-versions-to-keep }}
          DELETE_AFTER_DAYS: ${{ inputs.delete-after-days }}
          TAG_PREFIXES: ${{ inputs.tag-prefixes }}
          DRY_RUN: ${{ inputs.dry-run }}
          INCLUDE_UNTAGGED: ${{ inputs.include-untagged }}
          PROTECTED_TAGS: ${{ inputs.protected-tags }}
        run: |
          set -euo pipefail

          # Initialize summary file
          SUMMARY_FILE=$(mktemp)
          trap 'rm -f "$SUMMARY_FILE"' EXIT

          # URL-encode the package name (handle slashes in names like "repo/image")
          PACKAGE_NAME_ENCODED=$(printf '%s' "$PACKAGE_NAME" | jq -sRr @uri)

          echo "=== GHCR Lifecycle Management ==="
          echo "Package: $PACKAGE_OWNER/$PACKAGE_NAME"
          echo "Min versions to keep: $MIN_VERSIONS"
          echo "Delete after (days): $DELETE_AFTER_DAYS"
          echo "Tag prefixes: ${TAG_PREFIXES:-<none - global policy>}"
          echo "Dry run: $DRY_RUN"
          echo "Include untagged: $INCLUDE_UNTAGGED"
          echo "Protected tags: $PROTECTED_TAGS"
          echo

          # Start building summary
          {
            echo "## GHCR Lifecycle: $PACKAGE_OWNER/$PACKAGE_NAME"
            echo ""
            echo "| Setting | Value |"
            echo "|---------|-------|"
            echo "| Min versions to keep | $MIN_VERSIONS |"
            echo "| Delete after (days) | $DELETE_AFTER_DAYS |"
            echo "| Tag prefixes | ${TAG_PREFIXES:-*(global policy)*} |"
            echo "| Dry run | $DRY_RUN |"
            echo "| Include untagged | $INCLUDE_UNTAGGED |"
            echo "| Protected tags | $PROTECTED_TAGS |"
            echo ""
          } >> "$SUMMARY_FILE"

          # Calculate cutoff timestamp (seconds since epoch)
          CUTOFF_EPOCH=$(date -u -d "$DELETE_AFTER_DAYS days ago" +%s)
          CUTOFF_DATE=$(date -u -d "@$CUTOFF_EPOCH" +%Y-%m-%dT%H:%M:%SZ)
          echo "Cutoff date: $CUTOFF_DATE"
          echo ""

          # Determine if owner is a user or org
          OWNER_TYPE=$(gh api "users/$PACKAGE_OWNER" --jq '.type' 2>/dev/null || echo "Organization")

          if [ "$OWNER_TYPE" = "User" ]; then
            API_PATH="users/$PACKAGE_OWNER/packages/container/$PACKAGE_NAME_ENCODED/versions"
          else
            API_PATH="orgs/$PACKAGE_OWNER/packages/container/$PACKAGE_NAME_ENCODED/versions"
          fi

          echo "Owner type: $OWNER_TYPE"
          echo "Using API path: $API_PATH"
          echo ""

          # Fetch all versions (paginated)
          # Note: --paginate with --jq processes each page separately, so we need to
          # collect all pages first, then combine and process them
          echo "Fetching package versions..."
          RAW_VERSIONS=$(gh api --paginate "$API_PATH" 2>&1) || {
            echo "Error: Failed to fetch package versions"
            echo "$RAW_VERSIONS"
            echo ""
            echo "### âŒ Error" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "Failed to fetch package versions from API." >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo '```' >> "$SUMMARY_FILE"
            echo "$RAW_VERSIONS" >> "$SUMMARY_FILE"
            echo '```' >> "$SUMMARY_FILE"
            cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          }

          # Combine paginated results (each page is a JSON array) and extract needed fields
          VERSIONS_JSON=$(echo "$RAW_VERSIONS" | jq -s '
            [.[][] | {id: .id, name: .name, created_at: .created_at, tags: (.metadata.container.tags // [])}]
            | sort_by(.created_at) | reverse
          ') || {
            echo "Error: Failed to parse package versions"
            echo "Raw response:"
            echo "$RAW_VERSIONS"
            echo ""
            echo "### âŒ Error" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "Failed to parse package versions JSON." >> "$SUMMARY_FILE"
            cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          }

          TOTAL_VERSIONS=$(echo "$VERSIONS_JSON" | jq 'length')

          if [ "$TOTAL_VERSIONS" -eq 0 ]; then
            echo "No versions found for package $PACKAGE_NAME"
            echo "deleted-count=0" >> "$GITHUB_OUTPUT"
            echo "kept-count=0" >> "$GITHUB_OUTPUT"
            echo "dry-run-would-delete=0" >> "$GITHUB_OUTPUT"
            echo "### â„¹ï¸ No versions found" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "No container versions found for this package." >> "$SUMMARY_FILE"
            cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "Total versions found: $TOTAL_VERSIONS"
          echo ""

          # Build protected tag regex from glob patterns
          build_regex() {
            local patterns="$1"
            if [ -z "$patterns" ]; then
              echo ""
              return
            fi
            echo "$patterns" | tr ',' '\n' | while read -r pattern; do
              pattern=$(echo "$pattern" | xargs)  # trim whitespace
              [ -z "$pattern" ] && continue
              # Escape regex special chars, then convert globs
              echo "$pattern" | sed 's/[.^$+?{}|()\\[\\]]/\\&/g; s/\*/.*/g'
            done | paste -sd '|' -
          }

          PROTECTED_REGEX=$(build_regex "$PROTECTED_TAGS")
          if [ -n "$PROTECTED_REGEX" ]; then
            echo "Protected tag regex: ^($PROTECTED_REGEX)$"
            echo ""
          fi

          # Build tag prefixes JSON array
          if [ -n "$TAG_PREFIXES" ]; then
            TAG_PREFIXES_JSON=$(echo "$TAG_PREFIXES" | tr ',' '\n' | while read -r prefix; do
              prefix=$(echo "$prefix" | xargs)  # trim whitespace
              [ -z "$prefix" ] && continue
              echo "\"$prefix\""
            done | paste -sd ',' - | sed 's/^/[/; s/$/]/')
            echo "Tag prefix groups: $TAG_PREFIXES_JSON"
            echo ""
          else
            TAG_PREFIXES_JSON="[]"
          fi

          # Process versions using jq to handle the logic
          # When tag-prefixes is set, each prefix group gets its own min-versions quota
          RESULTS=$(echo "$VERSIONS_JSON" | jq --arg cutoff "$CUTOFF_EPOCH" \
            --arg min_versions "$MIN_VERSIONS" \
            --arg include_untagged "$INCLUDE_UNTAGGED" \
            --arg protected_regex "$PROTECTED_REGEX" \
            --argjson tag_prefixes "$TAG_PREFIXES_JSON" '
            def is_protected($tags; $regex):
              if $regex == "" then false
              elif ($tags | length) == 0 then false
              else ($tags | any(. as $tag | $tag | test("^(" + $regex + ")$")))
              end;

            def is_old($created_at; $cutoff):
              ($created_at | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) < ($cutoff | tonumber);

            # Find which prefix group a version belongs to (based on its tags)
            # Returns the first matching prefix, or "untagged" for untagged, or "other" for no match
            def get_prefix_group($tags; $prefixes):
              if ($tags | length) == 0 then "untagged"
              elif ($prefixes | length) == 0 then "all"
              else
                ($prefixes | map(. as $p | if ($tags | any(startswith($p))) then $p else null end) | map(select(. != null)) | first) // "other"
              end;

            # Initialize counters per prefix group
            (if ($tag_prefixes | length) > 0 then
              ($tag_prefixes + ["untagged", "other"]) | map({key: ., value: 0}) | from_entries
            else
              {"all": 0}
            end) as $initial_counts |

            reduce .[] as $v (
              {kept_counts: $initial_counts, protected: 0, to_delete: [], to_keep: []};

              ($v.tags | length) as $tag_count |
              ($tag_count == 0) as $is_untagged |
              is_protected($v.tags; $protected_regex) as $is_protected |
              is_old($v.created_at; $cutoff) as $is_old |
              get_prefix_group($v.tags; $tag_prefixes) as $prefix_group |

              if $is_protected then
                .protected += 1 |
                .to_keep += [{id: $v.id, name: $v.name, tags: $v.tags, reason: "protected", group: $prefix_group}]
              elif $is_untagged and ($include_untagged != "true") then
                .kept_counts[$prefix_group] += 1 |
                .to_keep += [{id: $v.id, name: $v.name, tags: $v.tags, reason: "untagged-excluded", group: $prefix_group}]
              elif .kept_counts[$prefix_group] < ($min_versions | tonumber) then
                .kept_counts[$prefix_group] += 1 |
                .to_keep += [{id: $v.id, name: $v.name, tags: $v.tags, reason: ("min-versions (" + $prefix_group + ": " + ((.kept_counts[$prefix_group]) | tostring) + "/" + $min_versions + ")"), group: $prefix_group}]
              elif $is_old | not then
                .kept_counts[$prefix_group] += 1 |
                .to_keep += [{id: $v.id, name: $v.name, tags: $v.tags, reason: "not-old-enough", group: $prefix_group}]
              else
                .to_delete += [{id: $v.id, name: $v.name, tags: $v.tags, created_at: $v.created_at, group: $prefix_group}]
              end
            ) |
            # Add total kept count
            .kept = ([.kept_counts[]] | add)
          ') || {
            echo "Error: Failed to process versions"
            echo "### âŒ Error" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            echo "Failed to process package versions." >> "$SUMMARY_FILE"
            cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          }

          # Extract counts and lists
          KEPT_COUNT=$(echo "$RESULTS" | jq '.kept')
          PROTECTED_COUNT=$(echo "$RESULTS" | jq '.protected')
          KEPT_COUNTS=$(echo "$RESULTS" | jq '.kept_counts')
          TO_DELETE=$(echo "$RESULTS" | jq '.to_delete')
          TO_DELETE_COUNT=$(echo "$TO_DELETE" | jq 'length')
          TO_KEEP=$(echo "$RESULTS" | jq '.to_keep')

          # Show per-group counts if using tag prefixes
          if [ -n "$TAG_PREFIXES" ]; then
            echo "=== Per-Group Version Counts ==="
            echo "$KEPT_COUNTS" | jq -r 'to_entries[] | "  \(.key): \(.value) kept"'
            echo ""

            {
              echo "### Per-Group Counts"
              echo ""
              echo "| Group | Kept |"
              echo "|-------|------|"
              echo "$KEPT_COUNTS" | jq -r 'to_entries[] | "| \(.key) | \(.value) |"'
              echo ""
            } >> "$SUMMARY_FILE"
          fi

          echo "=== Versions to Keep ($((KEPT_COUNT + PROTECTED_COUNT))) ==="
          echo "$TO_KEEP" | jq -r '.[] | "  \(.name) [\(.tags | join(", ") | if . == "" then "<untagged>" else . end)] - \(.reason)"'
          echo ""

          # Add kept versions to summary
          {
            echo "### âœ… Versions Kept ($((KEPT_COUNT + PROTECTED_COUNT)))"
            echo ""
            if [ "$((KEPT_COUNT + PROTECTED_COUNT))" -gt 0 ]; then
              echo "| Version | Tags | Reason |"
              echo "|---------|------|--------|"
              echo "$TO_KEEP" | jq -r '.[] | "| \(.name) | \(.tags | join(", ") | if . == "" then "*untagged*" else . end) | \(.reason) |"'
            else
              echo "*No versions kept*"
            fi
            echo ""
          } >> "$SUMMARY_FILE"

          if [ "$TO_DELETE_COUNT" -eq 0 ]; then
            echo "=== No versions eligible for deletion ==="
            echo "deleted-count=0" >> "$GITHUB_OUTPUT"
            echo "kept-count=$((KEPT_COUNT + PROTECTED_COUNT))" >> "$GITHUB_OUTPUT"
            echo "dry-run-would-delete=0" >> "$GITHUB_OUTPUT"

            {
              echo "### ðŸ—‘ï¸ Versions Deleted (0)"
              echo ""
              echo "*No versions eligible for deletion*"
            } >> "$SUMMARY_FILE"

            cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "=== Versions to Delete ($TO_DELETE_COUNT) ==="
          echo "$TO_DELETE" | jq -r '.[] | "  \(.name) [\(.tags | join(", ") | if . == "" then "<untagged>" else . end)] created \(.created_at) (group: \(.group))"'
          echo ""

          DELETED=0
          FAILED=0
          FAILED_VERSIONS=""

          if [ "$DRY_RUN" = "true" ]; then
            echo "=== DRY RUN - No versions will be deleted ==="
            echo "deleted-count=0" >> "$GITHUB_OUTPUT"
            echo "kept-count=$((KEPT_COUNT + PROTECTED_COUNT))" >> "$GITHUB_OUTPUT"
            echo "dry-run-would-delete=$TO_DELETE_COUNT" >> "$GITHUB_OUTPUT"

            {
              echo "### ðŸ” Versions That Would Be Deleted ($TO_DELETE_COUNT) - DRY RUN"
              echo ""
              echo "| Version | Tags | Created | Group |"
              echo "|---------|------|---------|-------|"
              echo "$TO_DELETE" | jq -r '.[] | "| \(.name) | \(.tags | join(", ") | if . == "" then "*untagged*" else . end) | \(.created_at) | \(.group) |"'
            } >> "$SUMMARY_FILE"
          else
            echo "=== Deleting versions ==="
            DELETED_VERSIONS=""
            DELETE_COUNT=0

            for id in $(echo "$TO_DELETE" | jq -r '.[].id'); do
              VERSION_INFO=$(echo "$TO_DELETE" | jq -r ".[] | select(.id == $id)")
              VERSION_NAME=$(echo "$VERSION_INFO" | jq -r '.name')
              VERSION_TAGS=$(echo "$VERSION_INFO" | jq -r '.tags | join(", ") | if . == "" then "*untagged*" else . end')
              VERSION_CREATED=$(echo "$VERSION_INFO" | jq -r '.created_at')
              VERSION_GROUP=$(echo "$VERSION_INFO" | jq -r '.group')

              printf "Deleting version %s (id: %s)... " "$VERSION_NAME" "$id"

              # Retry logic for rate limiting
              MAX_RETRIES=3
              RETRY_DELAY=5
              SUCCESS=false

              for attempt in $(seq 1 $MAX_RETRIES); do
                RESPONSE=$(gh api --method DELETE "$API_PATH/$id" 2>&1) && {
                  SUCCESS=true
                  break
                }

                # Check if rate limited
                if echo "$RESPONSE" | grep -q "429\|throttled"; then
                  if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                    echo "rate limited, waiting ${RETRY_DELAY}s (attempt $attempt/$MAX_RETRIES)..."
                    sleep $RETRY_DELAY
                    RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
                  fi
                else
                  # Not a rate limit error, don't retry
                  break
                fi
              done

              if [ "$SUCCESS" = true ]; then
                echo "OK"
                DELETED=$((DELETED + 1))
                printf -v ROW '| %s | %s | %s | %s |\n' "$VERSION_NAME" "$VERSION_TAGS" "$VERSION_CREATED" "$VERSION_GROUP"
                DELETED_VERSIONS="${DELETED_VERSIONS}${ROW}"
              else
                echo "FAILED"
                FAILED=$((FAILED + 1))
                printf -v ROW '| %s | %s | %s | %s |\n' "$VERSION_NAME" "$VERSION_TAGS" "$VERSION_CREATED" "$VERSION_GROUP"
                FAILED_VERSIONS="${FAILED_VERSIONS}${ROW}"
              fi

              # Rate limit prevention: pause every 10 deletions
              DELETE_COUNT=$((DELETE_COUNT + 1))
              if [ $((DELETE_COUNT % 10)) -eq 0 ]; then
                echo "  (pausing 2s to avoid rate limits...)"
                sleep 2
              fi
            done

            echo ""
            echo "=== Summary ==="
            echo "Protected: $PROTECTED_COUNT"
            echo "Kept: $KEPT_COUNT"
            echo "Deleted: $DELETED"
            if [ "$FAILED" -gt 0 ]; then
              echo "Failed to delete: $FAILED"
            fi

            echo "deleted-count=$DELETED" >> "$GITHUB_OUTPUT"
            echo "kept-count=$((KEPT_COUNT + PROTECTED_COUNT + FAILED))" >> "$GITHUB_OUTPUT"
            echo "dry-run-would-delete=0" >> "$GITHUB_OUTPUT"

            # Add deleted versions to summary
            {
              echo "### ðŸ—‘ï¸ Versions Deleted ($DELETED)"
              echo ""
              if [ "$DELETED" -gt 0 ]; then
                echo "| Version | Tags | Created | Group |"
                echo "|---------|------|---------|-------|"
                printf '%s' "$DELETED_VERSIONS"
              else
                echo "*No versions were deleted*"
              fi
              echo ""

              if [ "$FAILED" -gt 0 ]; then
                echo "### âš ï¸ Failed to Delete ($FAILED)"
                echo ""
                echo "| Version | Tags | Created | Group |"
                echo "|---------|------|---------|-------|"
                printf '%s' "$FAILED_VERSIONS"
                echo ""
              fi
            } >> "$SUMMARY_FILE"

            # Fail the workflow if any deletions failed
            if [ "$FAILED" -gt 0 ]; then
              echo "### âš ï¸ Workflow completed with errors" >> "$SUMMARY_FILE"
              echo "" >> "$SUMMARY_FILE"
              echo "Failed to delete $FAILED version(s). This may indicate rate limiting or permission issues." >> "$SUMMARY_FILE"
              echo "" >> "$SUMMARY_FILE"
              echo "**Tip:** If rate limited, re-run the workflow to continue cleanup. Successfully deleted versions won't be attempted again." >> "$SUMMARY_FILE"
              cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
          fi

          cat "$SUMMARY_FILE" >> "$GITHUB_STEP_SUMMARY"
